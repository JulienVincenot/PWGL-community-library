:Title "Description"

:section-start "Genetic Algorithms"

:section-start "Purpose"

:bodytext "        The purpose of a genetic algorithm (GA) is to try to find the global maximum of a function, known as the \"fitness function\", in situations where direct computation of the globally maximum solution (or \"most fit\" solution) is not practical or possible. The genetic algorithm falls under a class of algorithms known as \"stochastic optimization\" problems, because it uses stochastic (random) techniques to perform global optimization.
        Genetic algorithms are best suited for problems with large search spaces where the nature of the solution that satisfies (or at least approaches) the global maximum is unclear. The algorithm does not guarantee that it will find the global maximum, the solution it produces is simply a \"best effort\" solution. Usually, if the parameters of the genetic algorithm are set to reasonable values, it can find solutions that are quite satisfactory with relative efficiency."

:section-end


:section-start "The Algorithm"

:bodytext "    The algorithm works using a process that mimicks biological evolution. It begins with a randomly generated mating pool of solutions (known as the first \"generation\"). Next, the algorithm randomly selects solutions to reproduce into the next generation, favouring the solutions with higher fitness. During the reproduction into the next generation, solutions are randomly \"crossed over\" with one another (mimicking chromosomal crossover), and randomly mutated before they enter the next generation. These operations cause the algorithm to explore the search space around the more fit solutions in an effort to find better solutions. This process is repeated, generation after generation, until a termination condition is met.
        The details of the major operations used by the algorithm are outlined in the following sections."

:section-end

:section-start "Elitism"

:bodytext "        Elitism refers to the direct copying of the two most fit solutions from the current generation into the next generation. This library's GA allows the user to choose whether or not to use elitism. Using elitism always preserves the best solution into the next generation unchanged, whereas not using elitism provides slightly more exploration of the search space. In most cases, elitism should be used."

:section-end

:section-start "Selection"

:bodytext "        Selection refers to the process by which candidate solutions are selected to reproduce into the next generation. The most common form of selection, and the form of selection used in this library, is know as \"roulette wheel selection\". In roulette wheel selection, the probability of a solution being selected for reproduction into the next generation is proportional to its fitness in the current mating pool. This means that more fit solutions are more likely to move onto the next generations, but less fit solutions still have a chance of making it to the next generation (to promote a wider exploration of the search space)."

:section-end

:section-start "Crossover"

:bodytext "        Crossover refers to the combining of two parent solutions to produce two knew children. In this library, the form of crossover used is known as \"single point crossover\". In single point crossover, an index, known as the crossover point, is randomly chosen, then the two parent lists are split at that index. Then two children are generated by concatenating the first part of one list to the end of the other, and vice versa. 
        A genetic algorithm has a crossover probability, which is the probability that two selected parents will cross over with each other. Changing the crossover probability will have a significant effect on how the GA performs. Experimentation is the best way to determine a suitable crossover probability to use. Note that a higher crossover probability will cause a wider exploration of the search space, and vice versa."

:section-end

:section-start "Mutation"

:bodytext "        Mutation is the process by which solutions are randomly altered before entering the next generation. Given a specified mutation probability, each element in a solution is probabilistically altered to a different value in the search space. Changing the mutation probability will have a significant effect on how the GA performs. Experimentation is the best way to determine a suitable mutation probability to use. Note that a higher mutation probability will cause a wider exploration of the search space, and vice versa."

:section-end

:section-start "Termination"

:bodytext "        This library provides three different ways to determine when the GA is finished. These three termination methods are:"
:items
- "Terminate when a certain fitness level is reached - this will terminate the algorithm once a specified fitness level (or a higher fitness level) has been reached."
- "Termine after a number of generations - this methods terminates the algorthim after a given number of generations have been iterated through."
- "Terminate once the fitness plateaus - this terminates the algorithm once a given number of consecutive generations have the same best fitness."

:section-end

:section-start "Pseudo-code of a Genetic Algorithm"

:bodytext "The pseudo-code for the genetic algorithm in this library is as follows:"
:items
- "Generate random initial mating pool"
- "Sort the solutions in the mating pool by fitness"
- "Check if termination condition is satisfied. If so, terminate and return the most fit solution. Else:"
- "Copy the two most fit solutions into next generation (if elitism enabled)"
- "Select two parent solutions using roulette wheel selection"
- "Probabilistically perform crossover on the two parents to create children"
- "Probabilistically perform mutation on the children"
- "Copy the children into the next generation"
- "Repeat (5)-(8) until the next generation is full."
- "Go to (3)"

:section-end

:section-start "Comparable algorithms"

:bodytext "        There are many algorithms similar to genetic algorithms which can be used to perform stochastic optimization. A few of these include Simulated Annealing, Particle Swarm Optimization (PSO), and Stochastic Tunneling."

:section-end
:section-end

:section-start "Examples"

:bodytext "        The first three examples use trivial (yet illustrative) problems that show how to use the functions of the library. 

        The first example, \"ex01-trivialExample.pwgl\", shows how to find an optimized solution using a single heuristic rule (define using a PWGL abstract box in lambda mode) for the fitness function. 

        The second example, \"ex02-multipleFitnessFcns.pwgl\", shows how multiple heuristic rules can be specified. 

        The third example, \"ex03-trueFalseWithFitness.pwgl\", shows how true-or-false rules can be used in conjunction with heuristic rules.

        The last example, \"ex04-musicalExample.pwgl\", shows how the library can be used in a musical context, although again the example is quite trivial for illustrative purposes. Note that you need the FLAT library to run this example. You can download the FLAT library here: http://umanitoba.ca/studio-flat/download.php"

:section-end

:section-start "Potential Additions for Future Versions"

:bodytext "Some potential additions to future versions of this library include:"
:items
:list-style :french
- "Allow the user to pause the algorithm and obtain the current best solution, and then choose to continue execution of the algorithm from the same point, or restart the algorithm from the beginning."
- "Allow the user to control how much output the algorithm produces as it runs (using \"silent\", \"verbose\", and \"very verbose\" modes, for example)."
- "Facilitate the use of two-point crossover in addition to single point crossover, and allow the user to select which type of crossover to use."
- "Display more explicit error messages when invalid input values are entered."

:section-end

:section-start "Release Notes"
:bodytext "Negative fitness values are now allowed. Also fixed a bug where the total fitness of a given mating pool crashed the program. Now if total fitness sum is 0, candidates are uniformly chosen."

:section-end

:section-start "References"

:bodytext "For a good online tutorial of how genetic algorithms work, see: " 
:link "http://www.obitko.com/tutorials/genetic-algorithms/index.php" 
:protocol :http 
:link-text "http://www.obitko.com/tutorials/genetic-algorithms/index.php" 
:bodytext "(last accessed: April 24, 2011)"


:section-end

